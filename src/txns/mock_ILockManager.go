// Code generated by mockery v2.53.5. DO NOT EDIT.

package txns

import (
	common "github.com/Blackdeer1524/GraphDB/src/pkg/common"
	mock "github.com/stretchr/testify/mock"
)

// MockILockManager is an autogenerated mock type for the ILockManager type
type MockILockManager struct {
	mock.Mock
}

type MockILockManager_Expecter struct {
	mock *mock.Mock
}

func (_m *MockILockManager) EXPECT() *MockILockManager_Expecter {
	return &MockILockManager_Expecter{mock: &_m.Mock}
}

// LockCatalog provides a mock function with given fields: txnID, lockMode
func (_m *MockILockManager) LockCatalog(txnID common.TxnID, lockMode GranularLockMode) *CatalogLockToken {
	ret := _m.Called(txnID, lockMode)

	if len(ret) == 0 {
		panic("no return value specified for LockCatalog")
	}

	var r0 *CatalogLockToken
	if rf, ok := ret.Get(0).(func(common.TxnID, GranularLockMode) *CatalogLockToken); ok {
		r0 = rf(txnID, lockMode)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*CatalogLockToken)
		}
	}

	return r0
}

// MockILockManager_LockCatalog_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LockCatalog'
type MockILockManager_LockCatalog_Call struct {
	*mock.Call
}

// LockCatalog is a helper method to define mock.On call
//   - txnID common.TxnID
//   - lockMode GranularLockMode
func (_e *MockILockManager_Expecter) LockCatalog(txnID interface{}, lockMode interface{}) *MockILockManager_LockCatalog_Call {
	return &MockILockManager_LockCatalog_Call{Call: _e.mock.On("LockCatalog", txnID, lockMode)}
}

func (_c *MockILockManager_LockCatalog_Call) Run(run func(txnID common.TxnID, lockMode GranularLockMode)) *MockILockManager_LockCatalog_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(common.TxnID), args[1].(GranularLockMode))
	})
	return _c
}

func (_c *MockILockManager_LockCatalog_Call) Return(_a0 *CatalogLockToken) *MockILockManager_LockCatalog_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockILockManager_LockCatalog_Call) RunAndReturn(run func(common.TxnID, GranularLockMode) *CatalogLockToken) *MockILockManager_LockCatalog_Call {
	_c.Call.Return(run)
	return _c
}

// LockFile provides a mock function with given fields: t, fileID, lockMode
func (_m *MockILockManager) LockFile(t *CatalogLockToken, fileID common.FileID, lockMode GranularLockMode) *FileLockToken {
	ret := _m.Called(t, fileID, lockMode)

	if len(ret) == 0 {
		panic("no return value specified for LockFile")
	}

	var r0 *FileLockToken
	if rf, ok := ret.Get(0).(func(*CatalogLockToken, common.FileID, GranularLockMode) *FileLockToken); ok {
		r0 = rf(t, fileID, lockMode)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*FileLockToken)
		}
	}

	return r0
}

// MockILockManager_LockFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LockFile'
type MockILockManager_LockFile_Call struct {
	*mock.Call
}

// LockFile is a helper method to define mock.On call
//   - t *CatalogLockToken
//   - fileID common.FileID
//   - lockMode GranularLockMode
func (_e *MockILockManager_Expecter) LockFile(t interface{}, fileID interface{}, lockMode interface{}) *MockILockManager_LockFile_Call {
	return &MockILockManager_LockFile_Call{Call: _e.mock.On("LockFile", t, fileID, lockMode)}
}

func (_c *MockILockManager_LockFile_Call) Run(run func(t *CatalogLockToken, fileID common.FileID, lockMode GranularLockMode)) *MockILockManager_LockFile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*CatalogLockToken), args[1].(common.FileID), args[2].(GranularLockMode))
	})
	return _c
}

func (_c *MockILockManager_LockFile_Call) Return(_a0 *FileLockToken) *MockILockManager_LockFile_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockILockManager_LockFile_Call) RunAndReturn(run func(*CatalogLockToken, common.FileID, GranularLockMode) *FileLockToken) *MockILockManager_LockFile_Call {
	_c.Call.Return(run)
	return _c
}

// LockPage provides a mock function with given fields: ft, pageID, lockMode
func (_m *MockILockManager) LockPage(ft *FileLockToken, pageID common.PageID, lockMode PageLockMode) *PageLockToken {
	ret := _m.Called(ft, pageID, lockMode)

	if len(ret) == 0 {
		panic("no return value specified for LockPage")
	}

	var r0 *PageLockToken
	if rf, ok := ret.Get(0).(func(*FileLockToken, common.PageID, PageLockMode) *PageLockToken); ok {
		r0 = rf(ft, pageID, lockMode)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*PageLockToken)
		}
	}

	return r0
}

// MockILockManager_LockPage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LockPage'
type MockILockManager_LockPage_Call struct {
	*mock.Call
}

// LockPage is a helper method to define mock.On call
//   - ft *FileLockToken
//   - pageID common.PageID
//   - lockMode PageLockMode
func (_e *MockILockManager_Expecter) LockPage(ft interface{}, pageID interface{}, lockMode interface{}) *MockILockManager_LockPage_Call {
	return &MockILockManager_LockPage_Call{Call: _e.mock.On("LockPage", ft, pageID, lockMode)}
}

func (_c *MockILockManager_LockPage_Call) Run(run func(ft *FileLockToken, pageID common.PageID, lockMode PageLockMode)) *MockILockManager_LockPage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*FileLockToken), args[1].(common.PageID), args[2].(PageLockMode))
	})
	return _c
}

func (_c *MockILockManager_LockPage_Call) Return(_a0 *PageLockToken) *MockILockManager_LockPage_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockILockManager_LockPage_Call) RunAndReturn(run func(*FileLockToken, common.PageID, PageLockMode) *PageLockToken) *MockILockManager_LockPage_Call {
	_c.Call.Return(run)
	return _c
}

// Unlock provides a mock function with given fields: txnID
func (_m *MockILockManager) Unlock(txnID common.TxnID) {
	_m.Called(txnID)
}

// MockILockManager_Unlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Unlock'
type MockILockManager_Unlock_Call struct {
	*mock.Call
}

// Unlock is a helper method to define mock.On call
//   - txnID common.TxnID
func (_e *MockILockManager_Expecter) Unlock(txnID interface{}) *MockILockManager_Unlock_Call {
	return &MockILockManager_Unlock_Call{Call: _e.mock.On("Unlock", txnID)}
}

func (_c *MockILockManager_Unlock_Call) Run(run func(txnID common.TxnID)) *MockILockManager_Unlock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(common.TxnID))
	})
	return _c
}

func (_c *MockILockManager_Unlock_Call) Return() *MockILockManager_Unlock_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockILockManager_Unlock_Call) RunAndReturn(run func(common.TxnID)) *MockILockManager_Unlock_Call {
	_c.Run(run)
	return _c
}

// UpgradeCatalogLock provides a mock function with given fields: t, lockMode
func (_m *MockILockManager) UpgradeCatalogLock(t *CatalogLockToken, lockMode GranularLockMode) bool {
	ret := _m.Called(t, lockMode)

	if len(ret) == 0 {
		panic("no return value specified for UpgradeCatalogLock")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func(*CatalogLockToken, GranularLockMode) bool); ok {
		r0 = rf(t, lockMode)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// MockILockManager_UpgradeCatalogLock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpgradeCatalogLock'
type MockILockManager_UpgradeCatalogLock_Call struct {
	*mock.Call
}

// UpgradeCatalogLock is a helper method to define mock.On call
//   - t *CatalogLockToken
//   - lockMode GranularLockMode
func (_e *MockILockManager_Expecter) UpgradeCatalogLock(t interface{}, lockMode interface{}) *MockILockManager_UpgradeCatalogLock_Call {
	return &MockILockManager_UpgradeCatalogLock_Call{Call: _e.mock.On("UpgradeCatalogLock", t, lockMode)}
}

func (_c *MockILockManager_UpgradeCatalogLock_Call) Run(run func(t *CatalogLockToken, lockMode GranularLockMode)) *MockILockManager_UpgradeCatalogLock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*CatalogLockToken), args[1].(GranularLockMode))
	})
	return _c
}

func (_c *MockILockManager_UpgradeCatalogLock_Call) Return(_a0 bool) *MockILockManager_UpgradeCatalogLock_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockILockManager_UpgradeCatalogLock_Call) RunAndReturn(run func(*CatalogLockToken, GranularLockMode) bool) *MockILockManager_UpgradeCatalogLock_Call {
	_c.Call.Return(run)
	return _c
}

// UpgradeFileLock provides a mock function with given fields: ft, lockMode
func (_m *MockILockManager) UpgradeFileLock(ft *FileLockToken, lockMode GranularLockMode) bool {
	ret := _m.Called(ft, lockMode)

	if len(ret) == 0 {
		panic("no return value specified for UpgradeFileLock")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func(*FileLockToken, GranularLockMode) bool); ok {
		r0 = rf(ft, lockMode)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// MockILockManager_UpgradeFileLock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpgradeFileLock'
type MockILockManager_UpgradeFileLock_Call struct {
	*mock.Call
}

// UpgradeFileLock is a helper method to define mock.On call
//   - ft *FileLockToken
//   - lockMode GranularLockMode
func (_e *MockILockManager_Expecter) UpgradeFileLock(ft interface{}, lockMode interface{}) *MockILockManager_UpgradeFileLock_Call {
	return &MockILockManager_UpgradeFileLock_Call{Call: _e.mock.On("UpgradeFileLock", ft, lockMode)}
}

func (_c *MockILockManager_UpgradeFileLock_Call) Run(run func(ft *FileLockToken, lockMode GranularLockMode)) *MockILockManager_UpgradeFileLock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*FileLockToken), args[1].(GranularLockMode))
	})
	return _c
}

func (_c *MockILockManager_UpgradeFileLock_Call) Return(_a0 bool) *MockILockManager_UpgradeFileLock_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockILockManager_UpgradeFileLock_Call) RunAndReturn(run func(*FileLockToken, GranularLockMode) bool) *MockILockManager_UpgradeFileLock_Call {
	_c.Call.Return(run)
	return _c
}

// UpgradePageLock provides a mock function with given fields: pt, lockMode
func (_m *MockILockManager) UpgradePageLock(pt *PageLockToken, lockMode PageLockMode) bool {
	ret := _m.Called(pt, lockMode)

	if len(ret) == 0 {
		panic("no return value specified for UpgradePageLock")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func(*PageLockToken, PageLockMode) bool); ok {
		r0 = rf(pt, lockMode)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// MockILockManager_UpgradePageLock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpgradePageLock'
type MockILockManager_UpgradePageLock_Call struct {
	*mock.Call
}

// UpgradePageLock is a helper method to define mock.On call
//   - pt *PageLockToken
//   - lockMode PageLockMode
func (_e *MockILockManager_Expecter) UpgradePageLock(pt interface{}, lockMode interface{}) *MockILockManager_UpgradePageLock_Call {
	return &MockILockManager_UpgradePageLock_Call{Call: _e.mock.On("UpgradePageLock", pt, lockMode)}
}

func (_c *MockILockManager_UpgradePageLock_Call) Run(run func(pt *PageLockToken, lockMode PageLockMode)) *MockILockManager_UpgradePageLock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*PageLockToken), args[1].(PageLockMode))
	})
	return _c
}

func (_c *MockILockManager_UpgradePageLock_Call) Return(_a0 bool) *MockILockManager_UpgradePageLock_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockILockManager_UpgradePageLock_Call) RunAndReturn(run func(*PageLockToken, PageLockMode) bool) *MockILockManager_UpgradePageLock_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockILockManager creates a new instance of MockILockManager. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockILockManager(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockILockManager {
	mock := &MockILockManager{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
